# CN_CA_1 
# تماس صوتی زنده توزیع‌شده با استفاده از WebRTC


## مقدمه
در این پروژه، یک سیستم تماس صوتی زنده توزیع‌شده پیاده‌سازی شده است که از کتابخانه‌های Qt، WebRTC، Opus codec و Coturn استفاده می‌کند. این سیستم با هدف تبادل داده صوتی بین کاربران بدون وابستگی به سرور مرکزی طراحی شده است.

۱. پیاده‌سازی کلاس WebRTC
این کلاس، مدیریت ارسال و دریافت داده‌های صوتی از طریق پروتکل WebRTC را بر عهده دارد.

تعریف

WebRTC (Web Real-Time Communication) یک فناوری است که اجازه می‌دهد تا مرورگرها و برنامه‌های وب به طور مستقیم و بی‌واسطه، بدون نیاز به پلاگین‌های اضافی، ارتباطات صوتی، ویدئویی و داده‌ای را برقرار کنند.
مزایا
برقراری ارتباط مستقیم:  این امکان را می‌دهد که به راحتی و بدون نیاز به سرورهای مرکزی با یکدیگر ارتباط برقرار کنند.
کیفیت بالا: با استفاده از کدک‌های پیشرفته و پروتکل‌های بهینه، کیفیت صدا و تصویر بسیار بالایی ارائه می‌دهد.
پشتیبانی از مرورگرهای مختلف
قابلیت تبادل داده: علاوه بر تماس‌های صوتی و تصویری، WebRTC اجازه می‌دهد داده‌ها نیز به صورت مستقیم بین کلاینت‌ها تبادل شوند.
امنیت بالا: رمزنگاری (TLS و DTLS)
معایب
پیچیدگی در پیاده‌سازی: پیاده‌سازی WebRTC ممکن است برای توسعه‌دهندگان تازه‌کار پیچیده باشد، به ویژه در مدیریت ICE، SDP و سیگنالینگ.
نیاز به سرور سیگنالینگ: برای برقراری ارتباط بین دو کلاینت، یک سرور سیگنالینگ برای مبادله اطلاعات SDP و ICE ضروری است.

STUN و TURN
STUN (Session Traversal Utilities for NAT)
STUN یک پروتکل است که به دستگاه‌ها کمک می‌کند تا آدرس IP عمومی و پورت‌های مربوط به NAT (Network Address Translation) خود را شناسایی کنند. این پروتکل به دستگاه‌ها اجازه می‌دهد تا با استفاده از سرور STUN، آدرس‌های خود را به اشتراک بگذارند و بدین ترتیب ارتباط مستقیم بین دو کلاینت ایجاد کنند.

مزایا
سادگی و کارایی: در شرایط ایده‌آل (بدون NAT)، STUN می‌تواند ارتباط مستقیم را برقرار کند.
معایب
محدودیت در NAT: STUN در NAT‌های Symmetric کارایی خوبی ندارد و ممکن است در این شرایط به ارتباط مستقیم منجر نشود.

TURN (Traversal Using Relays around NAT)
TURN یک پروتکل است که در شرایطی که ارتباط مستقیم ممکن نیست (مثلاً در NAT‌های Symmetric)، به عنوان یک راه حل، از سرورهای TURN استفاده می‌کند. TURN به دستگاه‌ها این امکان را می‌دهد که از یک سرور Relay برای انتقال داده‌ها استفاده کنند.

مزایا
قابلیت اطمینان: TURN می‌تواند در هر شرایطی (حتی در NAT‌های Symmetric) ارتباط را برقرار کند.
پایداری: در شرایطی که NAT یا فایروال مانع از برقراری ارتباط مستقیم می‌شود، TURN می‌تواند به عنوان یک راه حل پشتیبان عمل کند.
معایب
تأخیر: استفاده از سرور TURN ممکن است باعث افزایش تأخیر در ارتباطات شود.
هزینه: راه‌اندازی و نگهداری از سرور TURN معمولاً هزینه‌بر است.

Coturn
تعریف
Coturn یک سرور TURN و STUN است که به عنوان یک راه حل Open Source برای حل مشکلات NAT traversal در WebRTC طراحی شده است. این سرور می‌تواند به عنوان یک سرور TURN و STUN عمل کند و به ارتباطات WebRTC کمک کند تا از مشکلات NAT عبور کنند.

مزایا
پشتیبانی از پروتکل‌های متعدد: Coturn از پروتکل‌های STUN و TURN پشتیبانی می‌کند و می‌تواند در محیط‌های مختلف استفاده شود.
قابلیت مقیاس‌پذیری
تنظیمات امنیتی: Coturn امکان استفاده از رمزنگاری و احراز هویت را فراهم می‌کند.
معایب

پیچیدگی پیکربندی: پیکربندی Coturn ممکن است برای کاربران تازه‌کار پیچیده باشد.
نیاز به منابع: سرورهای TURN به منابع بیشتری نسبت به STUN نیاز دارند، زیرا داده‌ها را به صورت Relay منتقل می‌کنند.


Signaling server
تعریف
سرور سیگنالینگ نقشی کلیدی در WebRTC ایفا می‌کند و مسئول مبادله اطلاعات اولیه بین کلاینت‌ها برای برقراری ارتباطات مستقیم است. این اطلاعات شامل SDP (Session Description Protocol) و ICE candidates است.

مزایا
مدیریت ارتباطات: سرور سیگنالینگ می‌تواند به مدیریت و تنظیم ارتباطات کمک کند.
سهولت استفاده: با استفاده از سرور سیگنالینگ، تبادل اطلاعات بین کلاینت‌ها ساده‌تر و کارآمدتر می‌شود.
معایب
وابستگی: نیاز به یک سرور سیگنالینگ به این معنی است که در صورت عدم دسترسی به آن، ارتباطات ممکن است تحت تأثیر قرار گیرند.
پیچیدگی: پیاده‌سازی یک سرور سیگنالینگ نیازمند توجه به جزئیات زیادی است.


<img width="688" alt="Screenshot 1403-08-15 at 23 42 24" src="https://github.com/user-attachments/assets/4135ef99-ff45-4806-a5b1-3f66ede61e95">
این تابع برای پیکربندی اولیه اتصال WebRTC استفاده می‌شود. در اینجا، STUN و TURN برای تسهیل ارتباط بین همتایان اضافه شده‌اند.
addPeer : این تابع همتای جدیدی را به اتصال اضافه می‌کند و تنظیمات STUN، توابع بازگشتی برای رویدادهای وضعیت اتصال (مانند Connected، Disconnected و ...) و اطلاعات مسیر جمع‌آوری (gathering state) را فراهم می‌کند.
setRemoteDescription: توصیف (SDP) همتا را دریافت کرده و تنظیم می‌کند.
setRemoteCandidate: کاندیداهای ICE همتا را اضافه می‌کند که برای بهبود ارتباط استفاده می‌شود.

۳. پیاده سازی کلاس AudioInput:

<img width="844" alt="Screenshot 1403-08-15 at 23 38 14" src="https://github.com/user-attachments/assets/f83c7219-369d-4e0b-934c-959df80860ad">
تنظیم فرمت صدا: یک شیء QAudioFormat ایجاد و فرمت صدا را با نرخ نمونه‌برداری، تعداد کانال و فرمت 16 بیتی تنظیم می‌کند.
ایجاد QAudioSource: با استفاده از تنظیمات فرمت، یک شیء QAudioSource برای ضبط صدا ایجاد می‌شود که داده‌های صوتی ضبط‌شده را به این کلاس ارسال می‌کند.
<img width="835" alt="Screenshot 1403-08-15 at 23 38 55" src="https://github.com/user-attachments/assets/a962f10d-1604-4b6b-bea8-484902624e5b">
تابع writeData: این تابع داده‌های صوتی را رمزگذاری می‌کند و آماده ارسال به سایر بخش‌ها می‌سازد.
رمزگذاری صدا: داده‌های خام صوتی با استفاده از Opus encoder فشرده‌سازی و در آرایه encodedData ذخیره می‌شود.
ارسال سیگنال voicePacketReady: پس از رمزگذاری، سیگنال voicePacketReady فرستاده می‌شود تا نشان دهد یک بسته صوتی آماده ارسال است. داده رمزگذاری‌شده می‌تواند برای انتقال به شبکه استفاده شود.
startRecording: این تابع ضبط صدا را شروع می‌کند و داده‌های صوتی را به این کلاس ارسال می‌کند.
stopRecording: این تابع ضبط صدا را متوقف می‌کند.


۳. پیاده سازی کلاس AudioOutput:

کلاس AudioOutput در این کد وظیفه پخش داده‌های صوتی دریافت‌شده را دارد و شامل پیکربندی فرمت صدا، مدیریت صف داده‌های صوتی، و پخش آن‌ها است. این کد به زبان C++ و با استفاده از کتابخانه‌های Qt و Opus برای کدکینگ صدا نوشته شده است. در ادامه، بخش‌های مختلف کد را توضیح می‌دهیم.
<img width="845" alt="Screenshot 1403-08-15 at 23 27 49" src="https://github.com/user-attachments/assets/19838c8d-f816-4782-8cfc-0c624602d406">

در این بخش، سازنده‌ی کلاس، فرمت صدا را با استفاده از تنظیماتی از قبیل نرخ نمونه‌برداری (48000 هرتز)، تعداد کانال‌ها (یک کانال یا مونو) و فرمت نمونه‌ها (16 بیتی) تنظیم می‌کند. سپس، یک شیء QAudioSink برای پخش صدا با این فرمت ایجاد می‌شود.

یک کدک Opus برای دیکد کردن داده‌های صوتی ایجاد می‌شود. نرخ نمونه‌برداری و تعداد کانال‌ها مشابه تنظیمات audioFormat است. اگر مشکلی در ایجاد کدک باشد، پیام خطا نمایش داده می‌شود.
 یک بافر QBuffer به عنوان منبع داده برای audioSink ایجاد می‌شود که به عنوان واسطی بین داده‌های صوتی و دستگاه پخش عمل می‌کند. همچنین، سیگنال newPacket به اسلات play متصل می‌شود تا در هنگام دریافت بسته‌های جدید، پخش انجام شود.
<img width="466" alt="Screenshot 1403-08-15 at 23 32 57" src="https://github.com/user-attachments/assets/d4c7b6d3-a235-4b4b-8d99-007da27b4081">

<img width="833" alt="Screenshot 1403-08-15 at 23 34 58" src="https://github.com/user-attachments/assets/c7c420fe-f347-463c-a7a3-49fa9d0bbd30">

این تابع داده‌های صوتی جدید را به صف packetQueue اضافه می‌کند. QMutexLocker برای جلوگیری از مشکلات همزمانی از قفل استفاده می‌کند. پس از افزودن داده‌ها، سیگنال newPacket ارسال می‌شود تا فرآیند پخش آغاز شود.

startPlaying: این تابع پخش را آغاز کرده و وضعیت stared را به true تغییر می‌دهد.
getStared: این تابع، وضعیت stared را برمی‌گرداند.
setStared: اگر مقدار stared تغییر کرده باشد، آن را به روزرسانی کرده و سیگنال staredChanged را ارسال می‌کند.
resetStared: وضعیت stared را به مقدار اولیه تنظیم می‌کند.

<img width="372" alt="Screenshot 1403-08-15 at 23 36 04" src="https://github.com/user-attachments/assets/51bc7957-1859-41bd-bd07-7245729cb2bb">

این تابع پخش صدا را متوقف می‌کند و در صورت نیاز، می‌توان عملیات پاکسازی اضافی را نیز در اینجا انجام داد.



این تصویر مربوط به خروجی تست websocket است:
![photo_1403-08-15 23 02 34](https://github.com/user-attachments/assets/6d30dd11-ba00-49cf-af24-7b317754beee)


![photo_1403-08-15 23 02 37](https://github.com/user-attachments/assets/772148e1-724d-4309-b77a-534c136d7918)





